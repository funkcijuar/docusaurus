/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

 function execute() {
  const translation = require('./translation.js');
  translation();

  const CWD = process.cwd();
  const fs = require('fs-extra');
  const readMetadata = require('./readMetadata.js');
  const renderToStaticMarkup = require('react-dom/server').renderToStaticMarkup;
  const path = require('path');
  const toSlug = require('../core/toSlug.js');
  const React = require('react');
  const mkdirp = require('mkdirp');
  const glob = require('glob');
  const Site = require('../core/Site.js');
  const siteConfig = require(CWD + '/siteConfig.js');
  let languages;
  if (fs.existsSync(CWD + '/languages.js')) {
    languages = require(CWD + '/languages.js');
  } else {
    languages = [{
      enabled: true,
      name: 'English',
      tag: 'en',
    }];
  }

  function writeFileAndCreateFolder(file, content) {
    mkdirp.sync(file.replace(new RegExp('/[^/]*$'), ''));

    fs.writeFileSync(file, content);
  }

  const TABLE_OF_CONTENTS_TOKEN = '<AUTOGENERATED_TABLE_OF_CONTENTS>';

  const insertTableOfContents = rawContent => {
    const regexp = /\n###\s+(`.*`.*)\n/g;
    let match;
    const headers = [];
    while ((match = regexp.exec(rawContent))) {
      headers.push(match[1]);
    }

    const tableOfContents = headers
      .map(header => `  - [${header}](#${toSlug(header)})`)
      .join('\n');

    return rawContent.replace(TABLE_OF_CONTENTS_TOKEN, tableOfContents);
  };

  console.log('generate.js triggered...');

  const regexSubFolder = /docs\/(.*)\/.*/;

  const enabledLanguages = [];
  languages.filter(lang => lang.enabled).map(lang => {
    enabledLanguages.push(lang.tag);
  });

  readMetadata.generateDocsMetadata();
  const Metadata = require('../core/metadata.js');
  let mdToHtml = {};
  for (let i = 0; i < Metadata.length; i++) {
    const metadata = Metadata[i];
    mdToHtml['/docs/' + metadata.language + '/' + metadata.source] = '/' + siteConfig.projectName + '/' + metadata.permalink;
  }

  const readCategories = require('./readCategories.js');
  let layouts = {};
  for (let i = 0; i < Metadata.length; i++) {
    let layout = Metadata[i].layout;
    if (layouts[layout] !== true) {
      layouts[layout] = true;
      readCategories(layout);
    }
  }

  const DocsLayout = require('../core/DocsLayout.js');

  fs.removeSync(__dirname + '/../../build');

  // create html files for all docs
  let files = glob.sync(CWD + '/../docs/**');
  files.forEach(file => {
    // console.log(file);
    let language = 'en';
    const match = regexSubFolder.exec(file);
    if (match) {
      language = match[1];
    }

    if (enabledLanguages.indexOf(language) === -1) {
      return;
    }

    const extension = path.extname(file);

    if (extension === '.md' || extension === '.markdown') {
      const result = readMetadata.processMetadata(file);

      const metadata = result.metadata;
      let rawContent = result.rawContent;

      /* generate table of contents if appropriate */
      if (rawContent && rawContent.indexOf(TABLE_OF_CONTENTS_TOKEN) != -1) {
        rawContent = insertTableOfContents(rawContent);
      }

      /* replace any links to markdown files to their website html links */
      Object.keys(mdToHtml).forEach(function(key, index) {
        rawContent = rawContent.replace(new RegExp(key,'g'), mdToHtml[key]);
      });

      const docComp = <DocsLayout metadata={metadata} language={language} config={siteConfig}>{rawContent}</DocsLayout>;
      const str = renderToStaticMarkup(docComp);

      let targetFile = __dirname + '/../../build' + '/' + siteConfig.projectName + '/' + metadata.permalink;
      // console.log(targetFile);
      writeFileAndCreateFolder(targetFile, str);
    }
  });

  // create html files for all blog posts
  if (fs.existsSync(__dirname + '../core/MetadataBlog.js')) {
    fs.removeSync(__dirname + '../core/MetadataBlog.js');
  }
  readMetadata.generateBlogMetadata();
  const MetadataBlog = require('../core/MetadataBlog.js');
  const BlogPostLayout = require('../core/BlogPostLayout.js');

  files = glob.sync(CWD + '/../blog/**/*.*');
  files.sort().reverse().forEach(file => {
    /* convert filename ot use slashes */
    const filePath = path
      .basename(file)
      .replace('-', '/')
      .replace('-', '/')
      .replace('-', '/')
      .replace(/\./g, '-')
      .replace(/\-md$/, '.html');
    const result = readMetadata.extractMetadata(fs.readFileSync(file, {encoding: 'utf8'}));
    const rawContent = result.rawContent;
    const metadata = Object.assign(
      {path: filePath, content: rawContent},
      result.metadata
    );
    metadata.id = metadata.title;

    let language = 'en';
    const blogPostComp = <BlogPostLayout metadata={metadata} language={language} config={siteConfig}>{rawContent}</BlogPostLayout>;
    const str = renderToStaticMarkup(blogPostComp);

    let targetFile = __dirname + '/../../build' + '/' + siteConfig.projectName + '/' + 'blog/' + filePath;
    writeFileAndCreateFolder(targetFile, str);
  });
  // create html files for all blog pages
  const BlogPageLayout = require('../core/BlogPageLayout.js');
  const perPage = 10;
  for (
    let page = 0;
    page < Math.ceil(MetadataBlog.length / perPage);
    page++
  ) {
    let language = 'en';
    const metadata = {page: page, perPage: perPage};
    const blogPageComp = <BlogPageLayout metadata={metadata} language={language} config={siteConfig}></BlogPageLayout>
    const str = renderToStaticMarkup(blogPageComp);

    let targetFile = __dirname + '/../../build' + '/' + siteConfig.projectName + '/' + 'blog' + (page > 0 ? '/page' + (page + 1) : '') + '/index.html';
    writeFileAndCreateFolder(targetFile, str);
  }

  /* copy all static files from docusaurus */
  files = glob.sync(__dirname + '/../static/**');
  files.forEach(file => {
    let targetFile = file.replace('/lib/static/', '/build' + '/' + siteConfig.projectName + '/');

    if (file.match(/\.css$/)) {
      let cssContent = fs.readFileSync(file);
      cssContent = cssContent.toString().replace(new RegExp('{primaryColor}', 'g'), siteConfig.colors.primaryColor);
      cssContent = cssContent.replace(new RegExp('{secondaryColor}', 'g'), siteConfig.colors.secondaryColor);
      cssContent = cssContent.replace(new RegExp('{prismColor}', 'g'), siteConfig.colors.prismColor);

      mkdirp.sync(targetFile.replace(new RegExp('/[^/]*$'), ''));
      fs.writeFileSync(targetFile, cssContent);
    }
    else if (!fs.lstatSync(file).isDirectory()) {
      mkdirp.sync(targetFile.replace(new RegExp('/[^/]*$'), ''));
      fs.copySync(file, targetFile);
    }
  });

  /* copy all static files from user */
  files = glob.sync(CWD + '/static/**');
  files.forEach(file => {
    if (file.match(/\.css$/)) {
      const mainCss = __dirname + '/../../build' + '/' + siteConfig.projectName + '/' + 'css/main.css';
      let cssContent = fs.readFileSync(file);
      cssContent = fs.readFileSync(mainCss) + '\n' + cssContent;

      cssContent = cssContent.toString().replace(new RegExp('{primaryColor}', 'g'), siteConfig.colors.primaryColor);
      cssContent = cssContent.replace(new RegExp('{secondaryColor}', 'g'), siteConfig.colors.secondaryColor);
      cssContent = cssContent.replace(new RegExp('{prismColor}', 'g'), siteConfig.colors.prismColor);

      fs.writeFileSync(mainCss, cssContent);
    }
    else if (!fs.lstatSync(file).isDirectory()) {
      let parts = file.split('static');
      let targetFile = __dirname + '/../../build' + '/' + siteConfig.projectName + '/' + parts[1];
      mkdirp.sync(targetFile.replace(new RegExp('/[^/]*$'), ''));
      fs.copySync(file, targetFile);
    }
  });

  /* compile/copy pages from user */
  files = glob.sync(CWD + '/pages/**');
  files.forEach(file => {
    if (file.match(/\.js$/)) {
      let parts = file.split('pages');
      let tempFile = __dirname +'/../pages' + parts[1];
      tempFile = tempFile.replace(path.basename(file), 'temp' + path.basename(file));
      mkdirp.sync(tempFile.replace(new RegExp('/[^/]*$'), ''));
      fs.copySync(file, tempFile);

      let language = 'en';
      const regexLang = /\/pages\/(.*)\//;
      const match = regexLang.exec(file);
      let langParts = match[1].split('/');
      for (let i = 0; i < langParts.length; i++) {
        if (enabledLanguages.indexOf(langParts[i]) !== -1) {
          language = langParts[i];
        }
      }
      let targetFile = __dirname + '/../../build' + '/' + siteConfig.projectName + '/' + parts[1];
      targetFile = targetFile.replace(/\.js$/, '.html');
      const ReactComp = require(tempFile);
      const str = renderToStaticMarkup(<Site language={language} config={siteConfig}><ReactComp language={language}/></Site>);
      writeFileAndCreateFolder(targetFile, str);

      fs.removeSync(tempFile);
    }
    else if (!fs.lstatSync(file).isDirectory()) {
      let parts = file.split('pages');
      let targetFile = __dirname + '/../../build' + '/' + siteConfig.projectName + '/' + parts[1];
      mkdirp.sync(targetFile.replace(new RegExp('/[^/]*$'), ''));
      fs.copySync(file, targetFile);
    }
  });

  /* copy html files in 'en' to base level as well */
  files = glob.sync(__dirname + '/../../build' + '/' + siteConfig.projectName + '/' +'en/**');
  files.forEach(file => {
    let targetFile = file.replace('en/', '');
    if (file.match(/\.html$/)) {
      fs.copySync(file, targetFile);
    }
  });
}

module.exports = execute;
